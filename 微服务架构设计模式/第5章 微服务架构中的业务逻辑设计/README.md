## 5.1 业务逻辑组织模式
![image](https://github.com/lemonshen00/reading-record/assets/13763576/f7e080d9-f8b2-4723-9df7-f404277e7f02)

业务逻辑是服务中最为复杂的部分，在开发业务逻辑时，你应该以最适合应用程序的方式，精心地设计和组织业务逻辑。

*入站适配器*处理来自客户端的请求并调用业务逻辑。
*出站适配器*被业务逻辑调用，然后它们再调用其他服务和外部应用程序。

> 使用面向对象的语言并不能保证业务逻辑具有面向对象的设计。

组织业务逻辑有两种主要模式：面向过程的事务脚本模式和面向对象的领域建模模式。

### 5.1.1 使用事务脚本模式设计业务逻辑
使用与简单的业务逻辑，无需面向对象方法。

此模式的重要特征：实现行为的类与存储状态的类是分开的。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/f2d440a9-ac98-42c1-b045-ffe7ab0d6e60)

OrderService类是业务类，使用DAO操作数据库，例如OrderDao。数据对象（Order类）是纯数据，几乎没有行为。

> 模式：事务脚本
>
> 将业务逻辑组织为面向过程的事务脚本的集合，每种类型的请求都由一个脚本

### 5.1.2 使用领域模型模式设计业务逻辑
除非是非常简单的业务场景，否则不允许使用面向过程的设计方法

> 模式：领域模型
>
> 将业务逻辑组织为有具有状态和行为的类构成的对象模型。

在面向对象的设计中，业务逻辑由对象模型和相对较小的一些类的网络组成。
这些类通常直接对应于问题域中的概念。
在这样的设计中，有些类只有状态或行为，但很多类同时包含状态和行为，这样的类都是精心设计的。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/3cdba1af-9ae4-44d8-a18f-efd3eb7e277d)

### 5.1.3 关于领域驱动设计
DDD是对面向对象设计的改进，是开发复杂业务逻辑的一种方法

DDD战略：子域 + 限界上下文
DDD基本概念：实体、值对象、工厂、存储库、服务

DDD基本概念的说明：
- 实体：具有持久化ID的对象，具有生命周期的对象。具有相同属性值的两个实体仍然是不同的对象。在Java EE中，使用JPA@Entity进行持久化的类通常是DDD实体
- 值对象：作为值集合的对象，具有相同属性值的两个值对象可以互换使用。例子是Money类，它由币种和金额组成。
- 工厂：负责实现对象创建逻辑的对象或方法，该逻辑过于复杂，无法由类的构造函数直接完成。
- 存储库（repository）：用来访问持久化实体的对象，存储库也封装了访问数据库的底层机制。*一个聚合对应一个仓储*。
- 服务：实现不属于实体或值对象的业务逻辑的对象

## 5.2 使用聚合模式设计领域模型

传统面向对象设计中，领域模型由一组类和它们之间的关系组成，这些类通常被组织成包。
但是，缺少每个业务对象的明确边界。

### 5.2.1 模糊边界所带来的问题
缺少明确的边界会在更新业务对象时导致问题，典型的业务对象具有一些不变量，即必须始终强制执行的业务规则
例如，Order订单对象具有最小订单金额。FTGO应用必须始终确保任何更新订单的尝试都不违反最低订单金额这个不变量约束。
挑战在于，为了强制执行这些不变量约束，你必须仔细设计业务逻辑。

例如：让我们看一看当多个消费者一起创建订单是，如何确保满足最低订单金额这项不变量约束。
两位消费者山姆和玛丽，正在一起买东西（使用同一张订单），他俩同时意识到自己买的东西已经超出了预算。
山姆减少了点心的数量，玛丽减少了面包的数量。如下


![image](https://github.com/lemonshen00/reading-record/assets/13763576/b29d4a1b-9cec-4a35-bd33-2d0d9f7fa0a6)

由于缺乏明确的边界，每个消费者都使用*两个事务*来完成订单项的更改。第一个事务加载订单及其订单项。
用户界面在执行第二个事务之前验证是否满足订单最小值。
第二个事务使用乐观离线锁检查更新订单行项目的数量，*该检查验证订单行自第一个事务加载以来未被更改*。
在这种情况下，山姆将订单总金额减少了X美元，玛丽减少了Y美元。
因此，即使应用程序在每次消费者更新后执行的订单验证结果扔满足最低订单要求，Order也不再有效。

备注：上面的本质是，订单行的数量被更改了，所以导致乐观离线锁检查失败，最终事务失效了。
但实际上，这个单不应该失效，因为这个单满足最低订单金额的要求。

DDD的聚合旨在解决此问题。

### 5.2.2 聚合拥有明确的边界
聚合是一个边界内的领域对象（实体、值对象）的集群，可以将其视为一个单元。
它由根实体和可能的一个或多个其他实体和值对象组成。（一个聚合可能只有一个实体，实体又是充血模型）

> 模式：聚合
>
> 将领域模型组织为聚合的集合，每个聚合都是可以作为一个单元进行处理的一组对象组成的图

![image](https://github.com/lemonshen00/reading-record/assets/13763576/7a6c7e20-6b22-4bd4-8c50-5ab019559825)

图5-5显示了Order聚合将其边界。Order聚合由Order实体、一个或多个OrderLineItem值对象以及其他值对象组成。

聚合将领域模型分解为块，单独的每一块更容易理解。它们还阐述了加载、更新和删除等操作的范围。
这些操作作用于*整个聚合而不是部分聚合*（这个是核心，防止并发多事务失败）。
聚合通常从数据库中完整加载，从而避免了延迟加载所导致的任何复杂性。
删除聚合会从数据库中删除其所有对象（聚合根、实体、值对象）。

总结：聚合是一个整体，同时加载、更新、删除

#### 聚合代表了一致的边界

更新整个聚合而不是聚合的一部分，可以解决前面例子中遇到的一致性问题。
在聚合根上调用更新操作，这会强制执行各种不变量约束。
此外可以使用例如版本号或者数据库级锁锁定聚合根来处理并发性。
例如：客户端必须在Order聚合的跟上调用方法，而不是直接更新订单项的数量，这会强制执行包括最小订单金额在内的各种不变量约束。

#### 识别聚合是关键
聚合的价值不仅仅是帮助我们设计模块化的领域模型，更重要的是聚合必须遵守某些规则（如Order聚合必须遵守最低订单金额规则）

### 5.2.3 聚合的规则
#### 规则一：只引用聚合跟
客户端只能通过调用聚合根上的方法来更新聚合。
例如，服务使用存储库（repository）从数据库加载聚合并获取对聚合根的引用，它通过在聚合根上调用方法来更新聚合。
此规则可确保聚合能够强制执行各种不变量约束。（如Order订单类，必须满足最小订单金额规则）

#### 规则二：聚合间的引用必须使用主键
如图5-6所示，Order使用consumerId引用其Consumer，而不是直接引用Consumer对象。
传统的对象建模将领域模型中的外键视为不好的设计。
但是，使用主键而不是对象引用，意味着聚合是松耦合的，它确保聚合之间的边界得到很好的定义，并避免意外更新不同的聚合。

聚合同时也是存储的单元，这种方法让持久化变得简单。可轻松将聚合存储在NoSQL数据库中。
聚合也与存储库一一对应。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/2684827b-3255-4ea6-be54-076fe7b8180f)

#### 规则三：在一个事务中，只能创建或更新一个聚合
NoSQL不支持事务，聚合存储在NoSQL中，此约束还满足大多数NoSQL数据库的受限事务模型。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/9cd5fc78-bf9f-4c2c-849f-dccfb0c5a6b0)


上图中，Saga由三个事务组成，第一个事务更新服务A中的聚合X。其他两个事务都在B中，一个事务更新聚合X，一个更新聚合Y

### 5.2.4 聚合的颗粒度

聚合的粒度应该尽可能细化，因为聚合是事务的范围。
聚合过大，服务会变得更大，也会成为服务分解的障碍。

### 5.2.5 使用聚合设计业务逻辑
在典型的微服务中，大部分业务逻辑由聚合组成。其余的业务逻辑分布在领域服务和Saga中。
Saga编排本地事务的序列，以确保数据的一致性。
服务是业务逻辑的入口，由入站适配器调用。
服务使用存储库从数据库中检索聚合或将聚合保存到数据库。
每个存储库都由访问数据库的出站适配器实现。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/4af03944-56d1-49d1-ba02-5733a985e117)

业务逻辑由Order聚合、OrderService服务类、OrderRepository和一个或多个Saga组成。
OrderService调用OrderReository来保存和加载Order。
对于能在服务内部完成处理的简单请求，服务直接更新Order聚合。
如果更新跨越多个服务，OrderService将创建一个Saga。

## 5.3 发布领域事件
领域事件，是*聚合*发生的事件，通常代表*状态的变化*。
例如，Order聚合的状态变化事件，包括Order Created、Order Cancelled、Order Shipped等。

聚合可以在每次进行状态变化时发布一个或多个事件，给那些感兴趣的接收方。

> 模式：领域事件
>
> 聚合在被创建时，或发生其他重大更改时发布领域事件。


### 5.3.1 为什么需要发布变更事件
领域事件很有用，因为应用程序的其他协作方通常有兴趣了解聚合的状态更改。以下是一些可能的场景：
- 使用基于编排的Saga维护服务之间的数据一致性（监听状态变化，再做动作）
- 通知维护数据副本的服务，源数据已经发生了更改。
- 通过Webhook（流水线用的这个）或消息代理通知不同的应用程序，以触发下一步业务流程
- 向用户发送短信或电子邮件通知，告知订单已发货、或航班延误

### 5.3.2 什么是领域事件
在命名领域事件时，我们往往选择动词的过去分词，如OrderCreated事件。

领域事件通常包含：
- 事件ID和时间戳
- 此次更改的用户的身份，因为这对用户行为审计很有用
- orderId

OrderCreated事件是领域事件的一个例子，它没有任何字段，因为订单聚合ID是事件信封对象的一部分。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/cdf4e8a7-33e2-4c3e-a0ee-ebdf205b7e25)


上面是一个领域事件的代码示例。DomainEvent接口是一个标识接口，用于将子类标识为领域事件。
OrderDomainEvent是Order聚合发布的事件的标识接口（如OrderCreated）。
DomainEventEnvelope是一个包含事件元数据和事件对象的类。

### 5.3.3 事件增强
事件增强是指，事件包含了接收方需要的信息，它简化了事件接收方，他们不再需要从发布事件的服务请求数据。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/2ee0e8ab-6e98-4af6-ac33-2310f23e34b0)


事件增强简化了接收方，但缺点是它可能会使领域事件的稳定性降低。
每当接收方的需求发生变化是，事件类都可能需要更改。

### 5.3.4 识别领域事件

事件风暴

### 5.3.5 生成和发布领域事件
突然想到一个问题：
以前做LDM，实际就是在设计聚合，因为聚合可能是多个实体、值对象。
而LDM落地为PDM时，将多个逻辑表组合成一个物理表，实际就是一个聚合，方便按事务性的处理添删改查。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/3701af3e-03d6-4eef-a7cd-abbbb5c7861d)

Kitchen Service微服务主要负责实现餐馆的订单管理功能。
该服务的两个主要聚合是Restaurant和Ticket。
Restaurant 聚合知道餐馆的菜单和营业时间，并可以验证订单。
Ticket代表餐馆厨房的工单，工单烹饪完成后由送餐员负责派送。

除了聚合之外，Kitchen Service业务逻辑的其他核心部分是KitchenService、TicketRepository和RestaurantRepository。
KitchenService是业务逻辑的入口。所有的入站适配器与它交互。
TicketRepository和RestaurantRepository负责持久化聚合信息（Repository是聚合维度的，一个聚合一个Repository）。

三个入站适配器：
- REST API：餐馆工作人员通过他们的用户界面调用这些REST API。它调用KitchenService来创建和更新Ticket
- KitchenServiceCommandHandler：由Saga调用的基于异步请求/响应的API，它调用KitchenService来创建和更新Ticket
- KitchenServiceEventConsumer：定于Restaurant Service发布的事件。它调用KitchenService来创建和更新Restaurant聚合。

该服务还有两个出站适配器：
- DB Adapter：实现TicketRepository和RestaurantRepository接口并访问数据库
- DomainEventPublishingAdapter：实现DomainEventPublisher接口并发布Ticket领域事件。

问题：在哪个类里发布领域事件？
在KitchenService类中。










