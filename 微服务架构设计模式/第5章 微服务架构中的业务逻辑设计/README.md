## 5.1 业务逻辑组织模式
![image](https://github.com/lemonshen00/reading-record/assets/13763576/f7e080d9-f8b2-4723-9df7-f404277e7f02)

业务逻辑是服务中最为复杂的部分，在开发业务逻辑时，你应该以最适合应用程序的方式，精心地设计和组织业务逻辑。

*入站适配器*处理来自客户端的请求并调用业务逻辑。
*出站适配器*被业务逻辑调用，然后它们再调用其他服务和外部应用程序。

> 使用面向对象的语言并不能保证业务逻辑具有面向对象的设计。

组织业务逻辑有两种主要模式：面向过程的事务脚本模式和面向对象的领域建模模式。

### 5.1.1 使用事务脚本模式设计业务逻辑
使用与简单的业务逻辑，无需面向对象方法。

此模式的重要特征：实现行为的类与存储状态的类是分开的。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/f2d440a9-ac98-42c1-b045-ffe7ab0d6e60)

OrderService类是业务类，使用DAO操作数据库，例如OrderDao。数据对象（Order类）是纯数据，几乎没有行为。

> 模式：事务脚本
>
> 将业务逻辑组织为面向过程的事务脚本的集合，每种类型的请求都由一个脚本

### 5.1.2 使用领域模型模式设计业务逻辑
除非是非常简单的业务场景，否则不允许使用面向过程的设计方法

> 模式：领域模型
>
> 将业务逻辑组织为有具有状态和行为的类构成的对象模型。

在面向对象的设计中，业务逻辑由对象模型和相对较小的一些类的网络组成。
这些类通常直接对应于问题域中的概念。
在这样的设计中，有些类只有状态或行为，但很多类同时包含状态和行为，这样的类都是精心设计的。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/3cdba1af-9ae4-44d8-a18f-efd3eb7e277d)

### 5.1.3 关于领域驱动设计
DDD是对面向对象设计的改进，是开发复杂业务逻辑的一种方法

DDD战略：子域 + 限界上下文
DDD基本概念：实体、值对象、工厂、存储库、服务

DDD基本概念的说明：
- 实体：具有持久化ID的对象，具有生命周期的对象。具有相同属性值的两个实体仍然是不同的对象。在Java EE中，使用JPA@Entity进行持久化的类通常是DDD实体
- 值对象：作为值集合的对象，具有相同属性值的两个值对象可以互换使用。例子是Money类，它由币种和金额组成。
- 工厂：负责实现对象创建逻辑的对象或方法，该逻辑过于复杂，无法由类的构造函数直接完成。
- 存储库（repository）：用来访问持久化实体的对象，存储库也封装了访问数据库的底层机制。*一个聚合对应一个仓储*。
- 服务：实现不属于实体或值对象的业务逻辑的对象

## 5.2 使用聚合模式设计领域模型

传统面向对象设计中，领域模型由一组类和它们之间的关系组成，这些类通常被组织成包。
但是，缺少每个业务对象的明确边界。

### 5.2.1 模糊边界所带来的问题
缺少明确的边界会在更新业务对象时导致问题，典型的业务对象具有一些不变量，即必须始终强制执行的业务规则
例如，Order订单对象具有最小订单金额。FTGO应用必须始终确保任何更新订单的尝试都不违反最低订单金额这个不变量约束。
挑战在于，为了强制执行这些不变量约束，你必须仔细设计业务逻辑。

例如：让我们看一看当多个消费者一起创建订单是，如何确保满足最低订单金额这项不变量约束。
两位消费者山姆和玛丽，正在一起买东西（使用同一张订单），他俩同时意识到自己买的东西已经超出了预算。
山姆减少了点心的数量，玛丽减少了面包的数量。如下


![image](https://github.com/lemonshen00/reading-record/assets/13763576/b29d4a1b-9cec-4a35-bd33-2d0d9f7fa0a6)

由于缺乏明确的边界，每个消费者都使用*两个事务*来完成订单项的更改。第一个事务加载订单及其订单项。
用户界面在执行第二个事务之前验证是否满足订单最小值。
第二个事务使用乐观离线锁检查更新订单行项目的数量，*该检查验证订单行自第一个事务加载以来未被更改*。
在这种情况下，山姆将订单总金额减少了X美元，玛丽减少了Y美元。
因此，即使应用程序在每次消费者更新后执行的订单验证结果扔满足最低订单要求，Order也不再有效。

备注：上面的本质是，订单行的数量被更改了，所以导致乐观离线锁检查失败，最终事务失效了。
但实际上，这个单不应该失效，因为这个单满足最低订单金额的要求。

DDD的聚合旨在解决此问题。

### 5.2.2 聚合拥有明确的边界
聚合是一个边界内的领域对象（实体、值对象）的集群，可以将其视为一个单元。
它由根实体和可能的一个或多个其他实体和值对象组成。（一个聚合可能只有一个实体，实体又是充血模型）

> 模式：聚合
>
> 将领域模型组织为聚合的集合，每个聚合都是可以作为一个单元进行处理的一组对象组成的图

![image](https://github.com/lemonshen00/reading-record/assets/13763576/7a6c7e20-6b22-4bd4-8c50-5ab019559825)

图5-5显示了Order聚合将其边界。Order聚合由Order实体、一个或多个OrderLineItem值对象以及其他值对象组成。

聚合将领域模型分解为块，单独的每一块更容易理解。它们还阐述了加载、更新和删除等操作的范围。
这些操作作用于*整个聚合而不是部分聚合*（这个是核心，防止并发多事务失败）。
聚合通常从数据库中完整加载，从而避免了延迟加载所导致的任何复杂性。
删除聚合会从数据库中删除其所有对象（聚合根、实体、值对象）。

总结：聚合是一个整体，同时加载、更新、删除

#### 聚合代表了一致的边界

更新整个聚合而不是聚合的一部分，可以解决前面例子中遇到的一致性问题。
在聚合根上调用更新操作，这会强制执行各种不变量约束。
此外可以使用例如版本号或者数据库级锁锁定聚合根来处理并发性。
例如：客户端必须在Order聚合的跟上调用方法，而不是直接更新订单项的数量，这会强制执行包括最小订单金额在内的各种不变量约束。

#### 识别聚合是关键
聚合的价值不仅仅是帮助我们设计模块化的领域模型，更重要的是聚合必须遵守某些规则（如Order聚合必须遵守最低订单金额规则）

### 5.2.3 聚合的规则
#### 规则一：只引用聚合跟
客户端只能通过调用聚合根上的方法来更新聚合。
例如，服务使用存储库（repository）从数据库加载聚合并获取对聚合根的引用，它通过在聚合根上调用方法来更新聚合。
此规则可确保聚合能够强制执行各种不变量约束。（如Order订单类，必须满足最小订单金额规则）

#### 规则二：聚合间的引用必须使用主键
如图5-6所示，Order使用consumerId引用其Consumer，而不是直接引用Consumer对象。
传统的对象建模将领域模型中的外键视为不好的设计。
但是，使用主键而不是对象引用，意味着聚合是松耦合的，它确保聚合之间的边界得到很好的定义，并避免意外更新不同的聚合。

聚合同时也是存储的单元，这种方法让持久化变得简单。可轻松将聚合存储在NoSQL数据库中。
聚合也与存储库一一对应。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/2684827b-3255-4ea6-be54-076fe7b8180f)

#### 规则三：在一个事务中，只能创建或更新一个聚合
NoSQL不支持事务，聚合存储在NoSQL中，此约束还满足大多数NoSQL数据库的受限事务模型。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/9cd5fc78-bf9f-4c2c-849f-dccfb0c5a6b0)


上图中，Saga由三个事务组成，第一个事务更新服务A中的聚合X。其他两个事务都在B中，一个事务更新聚合X，一个更新聚合Y

### 5.2.4 聚合的颗粒度















