## 7.1 使用API组合模式进行查询
### 7.1.1 findOrder()查询操作

在单体应用中，由于数据驻留在单个数据库中，因此单体FIGO应用程序可以通过执行连接（join）各个表的单个SELECT
语句轻松检索订单详情信息。与此对比，在基于微服务的FTGO应用程序版本中，数据分散在以下服务中：
- Order Service：基本订单信息，包括详细信息和状态
- Kitchen Service：从餐厅的角度看订单的状态以及预计取餐时间
- Delivery Service：订单的交付状态、预计送餐事件以及送餐员的当前位置
- Accounting Service：订单的付款状态

### 7.1.2 什么是API组合模式
通过调用拥有数据的服务并组合结果来实现查询操作，它有两种类型的参与者：
- API组合器：它通过查询数据提供方的服务来实现查询操作
- 数据提供方服务：拥有查询返回的部分数据的服务

![image](https://github.com/lemonshen00/reading-record/assets/13763576/e4f6bf4b-ef1a-4821-884a-482b41a4ae9d)


> 模式：API组合
>
> 通过查询每个服务的API并组合结果，实现从多个服务检索数据的查询

低效内存连接

### 7.1.3 使用API组合模式实现findOrder()查询操作

![image](https://github.com/lemonshen00/reading-record/assets/13763576/69b8fbe6-7560-485e-af01-8eb393a83767)


### 7.1.4 API组合模式的设计缺陷
使用此模式时，你必须解决两个设计问题：
- 确定架构中的哪个组件是查询操作的API组合器
- 如何编写有效的聚合逻辑

#### 由谁来担任API组合器的角色
三个选择：
- 服务的客户端，如Web端

![image](https://github.com/lemonshen00/reading-record/assets/13763576/2dcc6368-6b7b-4942-9705-02c9643d6bf4)

- 由实现应用程序外部API的API Gateway

![image](https://github.com/lemonshen00/reading-record/assets/13763576/34b246fa-6ccf-4aa9-8b18-f2087534c0dd)

- 将API组合器实现为独立的服务（支付采用的方法）

![image](https://github.com/lemonshen00/reading-record/assets/13763576/81bfb352-bf12-4ded-9151-27d4f9ac3c3b)

API组合器应该使用响应式编程模型：
API组合器应尽可能地并行调用提供方服务，最大限度地缩短查询操作的响应时间。

为了是API组合器达到较高的可维护性、性能和可扩展性，它应该使用基于Java CompletableFuture、RxJava可观测
或其他类似的响应式设计。

### 7.1.5 API组合模式的好处和弊端
缺点：
- 增加了额外的开销
- 带来可用性降低的风险
- 缺乏事务数据一致性

#### 增加了额外的开销
它需要调用多个服务和查询多个数据库，这带来了额外的开销

#### 带了可用性降低的风险
一次查询至少涉及三个服务：API组合器，和至少两个提供方服务

对策：
- API组合器缓存提供方服务返回的数据，以提高性能
- 让API组合器返回不完整的数据

#### 缺乏事务一致性
从Order Service检索的Order可能处于CANCELED状态，而从Kitchen Service检索的响应Ticket可尚未取消。

## 7.2 使用CQRS模式
> 模式：命令查询职责隔离
>
> 使用事件来维护从多个服务复制数据的只读视图，借此实现对来自多个服务的数据的查询

### 7.2.1 为什么要使用CQRS
诸如findOrderHistory()之类的查询要求API组合器在某种程度上实现关系型数据库查询执行引擎的功能。

### 7.2.2 什么是CQRS
微服务架构中查询时经常会遇到的三个问题：
- 使用API组合模式检索分散在多个服务中的数据会导致昂贵、低效的内存中连接
- 拥有数据的服务将数据存储在不能有效支持所需查询的数据库中
- 隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询操作的服务

#### CQRS 隔离命令和查询
CQRS是命令查询职责隔离（Command Query Responsibility Segregation）的简称，即读写分离。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/d38ea127-edcf-4e00-88f7-42968df2fd8e)

CQRS将持久化数据模型和使用数据的模块分为两部分：命令端和查询端。
命令端模块实现：创建、更新和删除操作（CUD）
查询端模块实现：查询（R）

查询端通过订阅命令端发布的事件，使其数据模型与命令端数据模型保持同步。

查询端可以使用的数据库种类很灵活，只要数据库能够支持需要的查询功能即可。查询端和命令端的数据库类型，可以不一致。

#### CQRS和查询专用服务
查询服务通过订阅一个或多个其他服务发布的事件来确保它的数据库是不断更新的。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/ad8b633d-b7ce-4dff-b2ba-97d34de23b0c)

### 7.2.3 CQRS的好处
好处：
- 在微服务架构中高效地实现查询
- 高效地实现多种不同的查询类型
- 在基于事件溯源技术的应用程序中实现查询
- 更进一步的实现问题隔离

#### 在微服务架构中高效地实现查询
使用API组合模式实现查询有时会导致大规模数据集的昂贵、低效的内存中连接。
对于那些查询，使用易于查询的CQRS视图更加有效。

#### 高效地实现多种不同的查询类型
它使应用程序或服务能够高效地实现各种查询，通常通过定义一个或多个视图来避免单个数据库的限制。
因为如果是单个数据库，如NoSQL，只有非常有限的查询功能。

#### 在基于事件溯源技术的应用程序中实现查询
事件存储库仅支持基于主键的查询，CQRS模式定于由基于事件溯源的聚合发布的事件流，可以保持最新的聚合的一个或多个视图，
由此解决此限制。这也是几月事件溯源的应用查询总是使用CQRS的原因。


#### 更进一步的实现问题隔离
领域模型及其相应的持久化数据模型不必同时处理命令和查询（仅需处理命令）。
CQRS模式为服务的命令端和查询端定义了单独的代码模块和数据库模式。

### 7.2.4 CQRS的弊端
- 更加复杂的架构
- 处理数据复制导致的延迟

#### 处理数据复制导致的延迟
在命令端发布事件和在查询端处理该事件以及更新视图之间存在延迟。

两种方案：
- 一种解决方案：命令端和查询端API为客户端提供版本信息，使得客户端可以查询判断是否过时。
- 一种解决方案：用户界面（APP或WEB）可以在针对聚合的命令执行成功后，更新并使用其本地版本的领域模型数据，而不是查询

## 7.3 设计CQRS视图

![image](https://github.com/lemonshen00/reading-record/assets/13763576/686b9d34-eb32-4826-b5fb-6460e4886225)


在开发视图模块时，你必须做出一些重要的设计决策：
- 选择合适的底层数据库，并设计数据库结构
- 数据访问模块，需要支持幂等、并发更细（同时更新一条数据）
- 在现有应用程序中实现新视图或更改现有应用程序的模式时，必须实现一种机制，以便有效地构建或重建视图
- 你必须决定如何设计视图的客户端，以应对前面描述的复制延迟

### 7.3.1 选择视图存储库
NoSQL数据库通常是CQRS视图的一个很好的选择，CQRS可以利用它们的优势并忽略其弱点。
CQRS受益于NoSQL数据库更丰富的数据模型和性能。
它不收NoSQL数据库事务处理能力的限制，因为CQRS只需要使用简单的事务并执行一组固定的查询即可。

![image](https://github.com/lemonshen00/reading-record/assets/13763576/56e8085d-248b-4960-86e9-f085ba74e0e1)

#### 支持更新操作
在使用NoSQL数据库时，必须通过主键实现更新、删除操作。如果没有主键，需要建立映射关系保持主键，后通过主键操作。
范例：UinMap，存储了用户UIN到签约ID的映射，通过UIN查到签约ID，通过签约ID查询签约信息。


### 7.3.2 设计数据访问模块
