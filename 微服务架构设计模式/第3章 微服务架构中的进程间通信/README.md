## 3.1 微服务架构中的进程间通信概述
通信机制：基于同步请求/响应的，如HTTP REST或gRPC；
也可以用异步的基于消息的通信机制，比如AMQP(Advanced Message Queuing Protocol，如RabbitMQ)或者STOMP(Streaming Text Orientated Message Protocol)。

消息的格式：基于文本的如JSON或XML；或更加高效的，基于二进制的Avro或Protocol Buffers格式

### 3.1.1 交互方式
![664_1685667602_hd](https://github.com/lemonshen00/reading-record/assets/13763576/ab53d1f8-0b87-40b4-a914-46fee77f20ca)

- 一对一：每个客户端请求由一个服务实例来处理
- 一对多：每个客户端请求由多个服务实例来处理

如果使用了同步模式，则两个服务间是紧耦合的。

异步模式：
- 单向通知：客户端的请求发到服务端，但是并不期望服务端做出任何响应。
- 发布/订阅方式：客户端发布通知消息，被零个或多个感兴趣的服务订阅(客户端期待响应)。
- 发布/异步响应方式：客户端发布请求消息，然后等待从感兴趣的服务发回的响应(客户端期待响应，但是异步的)。

Java中为什么要设计接口？
因为接口可以暴露出来给客户端调用，而具体实现了接口的类则对外隐藏。

### 3.1.3 API的演化

应该进行次要并且向后兼容的改变，向后兼容 = 非破坏性改变，即老的客户端还能用

#### 向后兼容的更改是对API的附加更改或功能增强：
- 添加可选的属性(入参)
- 向响应添加属性(出参)
- 添加新操作

如果仅进行这些类型的更改，那么老版本的客户端将能够直接使用更新的服务。但是，服务应该为缺少的请求属性提供默认值。同样，客户端应该忽略额外的响应属性。

#### 进行主要并且不向后兼容的改变
如果进行了破坏性改变，并且一段时间内新旧API共存，可通过在URL中嵌入主要的版本号来区分，如/v1/…，或/v2/…；
或者使用HTTP的内容协商机制，并在MIME类型中包含版本号。如下：

GET /orders/xyz HTTP/1.1
Accept: application/vnd.example.resource+json; version=1

### 3.1.4 消息的格式
进程间通信的本质是交换消息。消息通常包含数据，需要决定数据的格式。
如果选择gRPC，其已经确定了消息格式(PB)；但如果选择类似于HTTP的消息系统，就需要选择消息的格式。

不应该选择类似Java序列化这样跟编程语言强相关的消息格式。

#### 基于文本的消息格式
如JSON或XML，好处是可读性高，同时是自描述的。

缺点是：消息过于冗长，例如需要反复包含除了值以外的属性名称。另外，解析文本引入额外的开销。

#### 二进制消息格式
Protocol Buffers和Avro

## 3.2 基于同步远程过程调用模式的通信

![screen_shot_1685668064341](https://github.com/lemonshen00/reading-record/assets/13763576/731a3c31-a029-4d03-a4b8-7c0ba6e19cf1)


### 3.2.1 使用REST
REST中的一个关键概念是资源，它通常表示单个业务对象，例如客户或产品，或业务对象的集合。
REST使用HTTP动词来操作资源，如GET请求返回资源，POST请求创建资源，PUT请求更新资源。
例如 POST/order，GET/orders/{orderId}

#### 挑战：在一个请求中获取多种资源
如何一个REST请求获取多种资源，如一次获取订单和顾客信息？

GET/orders/ order-id-1345?expand=consumer 检索order及其Consumer。
请求中的查询参数用来指定要与order一起返回的相关资源，但方法很耗时。

可以通过GraphQL技术解决。

#### 挑战：把操作映射为 HTTP 动词(核心缺点)
另一个常见的REST API设计问题是如何将要在业务对象上执行的操作映射到 HTTP 动词。
REST API应该使用 PUT 进行更新，但可能现实中有多种方法更新订单，包括取消订单、修改订单等，
解决办法：POST/orders/{orderId}/cancel，但不符合RESTful的要求。

映射到HTTP动作这个挑战导致了REST替代方案的日益普及，如gRPC。

#### REST的好处
- 它非常简单，并且大家都很熟悉。
- 可以使用浏览器扩展（比如Postman插件）或者curl 之类的命令行（假设使用的是
JSON 或其他文本格式）来测试 HTTP API
- 直接支持请求 /响应方式的通信。
- HTTP 对防火墙友好。
- 不需要中间代理，简化了系统架构。

它也存在一些弊端：

- 它只支持请求 / 响应方式的通信。
- 可能导致可用性降低。由于客户端和服务直接通信而没有代理来缓冲消息，因此它们必须在 REST API 调用期间都保持在线。
- 客户端必须知道服务实例的位置（URL)。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到 HTTP 动词。


### 3.2.2 使用gRPC
gRPC使用基于PB的IDL语言定义API。除了支持简单的请求/响应RPC外，还支持流式RPC。服务器可以使用消息流回复客广端。客户端也可以向服务器发送消息流。

gRPC使用PB作为消息格式，无他选。gRPC向后兼容，因为Protocol Buffers 消息的每个字段都有编号，消息接收方可以提取所需的字段，并跳过它无法识別的字段（未来的新字段）。

gRPC 有几个好处：
- 设计具有复杂更新操作的 API 非常简单。
- 它具有高效、紧凑的进程问通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和消息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种语言编写的服务端之间的互操作性。

gRPC也有几个弊端：
- 与其于 REST 的 API机制相比，Javascript 客户端使用基于gRPC 的 API需要做更多的工作。
- 旧式防火墙可能不支持 HTTP/2。

### 3.2.3 使用阻断器模式处理局部故障

> 模式：阻断器
>
> 这是一个远程过程调用的代理，在连续失败次数超过指定的阈值后的一段时间内，这个代理会立即拒绝其他调用

![screen_shot_1685929901997](https://github.com/lemonshen00/reading-record/assets/13763576/b9d3a768-b578-45f6-8b98-3625432b45ae)

如何合理设计服务来防止故障在整个应用程序中传导和扩散？

#### 开发可靠的远程过程调用代理

- 设置网络超时时间，而不是线程无限阻塞浪费资源
- 限制客户端向服务器发出请求的数量：把客户端能够向特定服务发起的请求设置一个上限，达到上限立即返回失败
- 阻断器模式：监控客户端发出请求的超过和失败数量，如果达到一定阈值，启动阻断器，让请求立即失效。

#### 从服务失效故障中恢复

当局部故障发生时，需要根据故障的重要性决定如何恢复。如果是核心微服务失败，可直接返回失败；

否则可以使用缓存数据，或者默认数据，或者不显示相关信息。


### 3.2.4 使用服务发现

服务发现的关键组件是服务注册表，它是包含服务实例网络位置信息的一个数据库。

实现服务发现有两种主要方式：

- 服务及其客户端直接与服务注册表交互(应用层服务发现模式)


- 通过部署基础设施来处理服务发现(平台层服务发现模式)


#### 服务及其客户端直接与服务注册表交互
![screen_shot_1685930684242](https://github.com/lemonshen00/reading-record/assets/13763576/8d34ba7b-aac2-4efe-b76c-82c82458d0ca)


此模式有核心的两个模式：

> 模式：自注册
>
> 服务实例向服务注册表注册自己。



> 模式：客户端发现
>
> 客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载均衡

上述模式的一个典型应用，就是Neflix开发的组件Eureka(希腊语，我发现啦！)

优点：可以处理多平台部署的问题，如在K8S上部署了一些服务，其余服务在遗留环境中运行，在这种情况下Eureka的应用层服务发现

同时适用于这两种环境



缺点：需要为每种变成语言提供服务发现库(客户端调用服务注册表)；开发这负责设置和管理服务注册表



#### 通过部署基础设施来处理服务发现

![screen_shot_1685930130047](https://github.com/lemonshen00/reading-record/assets/13763576/9700544d-c95d-4d14-a427-ded220d50113)

每个微服务都有一个网络位置（物理IP），虚拟地址（VIP），一个DNS名称（可以配置的，如order-service），客户端使用DNS名称order-service
访问微服务Order Service，该服务被平台解析为VIP（K8S就这么做的）


由上图可知，平台层服务发现模式中，多了一个平台路由器和注册器，客户端与平台路由器交互；服务端与注册器交互；

双方都不再直接操作服务注册表。



优点：服务发现的所有方面完全由部署平台处理，服务和客户端不包含任何服务发现代码，因此是跨语言和框架平台的

缺点：仅限于支持该平台部署的服务，如基于K8S的发现仅适用于在K8S上运行的服务



## 3.3 基于异步消息模式的通信

### 3.3.1 什么是消息传递
#### 关于消息

消息由消息头部和消息主体组成，消息头部包含：消息的标题（名称与值对的集合，由发送者指定）和消息ID，以及可选
的返回地址，该地址指定发送回复的消息通道。消息主体是文本或者二进制格式的数据。

有几种不同类型的消息
- 文档式消息：仅包含数据的通用消息，消费者决定如何使用数据
- 命令式消息：一条等同于RPC请求的消息，它指定要调用的操作及其参数
- 事件式消息：表示发送方这一端发生了重要的事件，通常是领域事件，表示领域对象（如订单、顾客）的状态更改

![screen_shot_1685930796317](https://github.com/lemonshen00/reading-record/assets/13763576/1cdbf600-43aa-4335-ae42-0fa7474f8829)


消息通道分两种类型：
- 点对点通道：服务使用点对点通道实现一对一交互方式，例如，命令式消息通常通过点对点通道发送
- 发布订阅通道：服务使用发布订阅通道实现一对多交互方式，例如，事件式消息通常通过发布-订阅通道发送

### 3.3.2 使用消息机制实现交互方式
使用消息可以实现各种通信方式，如请求/响应、异步请求/响应、发布/订阅、发布/异步响应

### 3.3.3 为基于消息机制的服务API创建API规范

### 3.3.4 使用消息代理
> 消息代理，即服务通信的基础设施服务

消息传递架构分为两种：
- 无代理，服务直接相互通信
- 有代理，服务通过代理通信

#### 无代理消息
在无代理的架构中，服务可以直接交换消息，ZeroMQ是一种流行的无代理消息技术

无代理架构的优点：
- 低延迟
- 消除消息代理可能成为性能瓶颈或单点故障的可能性
- 具有较低的操作复杂性


无代理架构的缺点：
- 服务需要了解彼此的位置，需要服务发现机制
- 可用性降低，即发送方和接收方必须同时在线
- 无法确保消息能够正常投递

#### 使用消息代理

消息代理的优点：
- 无需知道接收方的网络位置
- 消息代理缓冲消息，直到接收方可以处理它们

有许多消息代理可选，流行的开源消息代理包括：
- ActiveMQ
- RabbitMQ
- Kafka

选择消息代理时，需要考虑如下因素：
- 支持的编程语言
- 支持的消息标准
- 消息顺序：消息代理能否保留消息的排序
- 投递保证：提供什么样的消息投递保证？
- 持久性：消息是否持久化保存到磁盘并且能够在代理泵口试恢复？
- 耐久性：如果接收方重新连接到消息代理，它是否会收到断开连接时发送的消息？
- 可扩展性
- 延迟：端到端是否有较大的延迟
- 竞争性接收方：消息代理是否支持竞争性接收方

#### 基于代理的消息的好处和弊端
优点：
- 松耦合
- 消息缓存：接收方可以临时不在线，后面也可以处理
- 灵活的通信：消息机制支持前面提到的所有交互方式
- 明确的进程间通信：基于RPC的机制总是企图让远程服务调用跟本地调用看上去没什么区别，实际区别巨大。消息机制让这些差异变得明确。

缺点：
- 潜在的性能瓶颈：解决方案，多数消息代理都支持高度的横向扩展
- 潜在的单点故障：多数消息代理都是高可用的
- 额外的操作复杂性：消息系统是一个必须独立安装、配置和运维的系统组件



### 3.3.5 处理并发和消息顺序

挑战有两个

- 如果消费者有多个，则1/2/3三个消息可能被分到三个不同消费者，造成消费顺序错乱
- 如果消费者有1个，1/2/3三个消息可能被三个不同的线程处理，造成消费顺序错乱


解决办法：

![screen_shot_1685930957600](https://github.com/lemonshen00/reading-record/assets/13763576/acb7d8da-80dd-482f-ba2d-f4bd0a28f80f)


针对问题1，Kafka将一个Topic分为多个partition，每个partition可以对应一个稳定的消费者，但需要消息中带入partiton id。

另外，partition通过加锁的方式，确保了消息的有序入队和出队，如1/2/3的顺序。



上述办法解决了问题1，针对问题2，可以通过内存队列。即消息1/2/3进入同一个内存队列（可以根据消息id做散列，即可进入同一个队列），每个线程处理

一个内存队列，则可以保证线程内的消息有序。



### 3.3.6 处理重复消息

两个方法：

- 消费者支持幂等
- 跟踪消息并丢弃重复消息：消息接收方通过在数据库表中记录已处理消息的ID来检测并丢弃重复消息



### 3.3.7 事务性消息

有时，数据库的更新和消息发送必须在事务中进行，如先更新数据库后发送消息，否则服务可能会更新数据库成功，但发送消息失败。

即更新数据库和发送消息需要具有原子性。



传统的办法是在数据库和消息代理之间使用分布式事务，但是这不是一个好的选择，因为很多新的消息代理，例如Kafka不支持分布式事务。



解决办法是使用数据库作为消息队列



#### 使用数据库表作为消息队列

![screen_shot_1685931069709](https://github.com/lemonshen00/reading-record/assets/13763576/adc4bc28-69a6-474c-bc48-a03d5750efb4)


步骤如下：

1.  更新业务表
2.  插入消息表

上述两个操作是原子性的，然后，消息组件读取消息表来发布消息。由于表的操作是原子性的，保证了消息的事务性。



如何将消息表中的数据移动到消息队列中？

有两种方式：

- 轮询数据表
- 使用事务日志拖尾模式



#### 轮询发布数据

即轮询数据库表数据，缺点是轮询数据库可能造成昂贵的开销



#### 使用事务日志拖尾模式发布事件

每次更新数据库表，都会对应数据库的事务日志文件的一个条目，通过tail这个日志文件即可发布消息。有一些开源项目可以使用，

例如你可以使用开源框架Debezium将应用程序对MySQL、Postgres或者MongoDB所做的更改发布到Kafka。








## 3.4 使用异步消息提高可用性

### 3.4.1 同步消息会降低可用性

如果你想最大化一个系统的可用性，就应该设法最小化系统的同步操作量。



### 3.4.2 消除同步交互

#### 使用异步交互模式

理想的情况下，将所有的交互全部改为异步交互，如下图。


![screen_shot_1685931169213](https://github.com/lemonshen00/reading-record/assets/13763576/aec1d4f2-a9f5-42f4-93a2-65aa14f9e45c)


#### 复制数据

服务维护数据的副本，数据源发生变化时发出消息，服务订阅这些消息来确保数据副本实时更新。

优点：服务拥有所有数据，无需访问下游服务即可完成业务逻辑。

缺点：数据量太大时效率低下



#### 先返回响应，再完成处理

另一种在请求处理环节消除同步通信的办法如下：

- 仅使用本地数据完成请求验证（无RPC实时交互）
- 更新数据库，创建初始态订单
- 向客户端返回响应

上述模式可以用Saga实现，类似于委托代扣中的受理扣款模式。



优点：提升可用性，即使某个服务挂掉，仍可以创建订单并响应客户。最终，挂掉的服务将重启并处理队列中的消息。

缺点：使得客户端复杂，客户端需要轮询，或者需要等待服务端的通知才能知道订单状态。

