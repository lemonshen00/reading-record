## 2.1 微服务架构到底是什么
在聊微服务架构是什么之前，需要先了解什么是软件架构，软件的架构是一种抽象的结构，它由软件的各个组成部分和这些部分之间的依赖关系构成。

传统上，软件架构的目标是可扩展性、可用性和安全性，但是今天，该架构能够快速安全的交付软件，这一点非常重要。微服务架构是一种架构风格，可为应用程序提供更高的可维护性、可测试性和可部署性。

### 2.1.1 软件架构是什么，为什么它如此重要
#### 软件架构的定义
>计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。 ---卡梅隆大学 Bass等

这是一个抽象的定义，但实质是应用程序的架构是将软件分解为元素和这些元素之间的关系。

#### 软件架构的4+1视图模型
从更*具体*的角度而言，软件架构可以从多个视角来看，就像建筑架构，一般有结构、管线、电气等多个架构视角。

下图定义了四个不同的软件架构视图，每一个视图都只描述架构的一个特定的方面，每个视图包括一些特定的软件元素和它们相互之间的关系。

![screen_shot_1685525810729](https://github.com/lemonshen00/reading-record/assets/13763576/7cc08988-b60b-49a1-8013-be3453cb0b78)
每个视图的目的如下：
- 逻辑视图：开发人员创建的软件元素，如类和包。它们之间的关系是类和包之间的关系，包括继承、关联和依赖
- 实现视图：构建编译系统的输出，此视图由表示打包代码的模块和组件组成，组件是由一个或多个模块组成的可执行单元。在JAVA中，模块是JAR文件，组件是WAR文件或可执行的JAR文件。它们之间的关系包括模块之间的依赖关系以及组件和模块之间的组合关系。
- 进程视图：运行的组件。每个元素都是一个进程，进程之间的关系代表进程间通信。
- 部署视图：进程如何映射到机器。此视图中的元素由（物理或虚拟）计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系。

4+1中的1指的是场景，它负责把视图串联在一起。每个视图都描述了架构的一个重要侧面。

#### 为什么架构如此重要
应用程序有两个层面的需求，功能性需求和非功能性需求。软件架构跟功能性需求没什么关系，甚至是非常糟糕的大泥球架构。

架构的重要性在于，它帮助程序实现了非功能性需求。这些非功能性需求决定了一个程序运行时的质量，比如可扩展性，可用性等。

### 2.1.2 什么是架构风格
在物理的世界中，建筑物通常遵循特定的风格，每种风格都是一系列设计决策，限制了建筑的特征和建筑材料

>架构风格确定了在该风格的实例中，使用的组件和连接器的词汇表，以及关于如何组合他们的一组约束 ---David Garlan

具体来说，特定的架构风格提供了有限的元素（组件）和元素关系（连接器）。应用程序可以使用多种架构风格的组合。

#### 分层架构风格
分层架构将软件元素按“层”的方式组织，每一层都只能依赖于紧邻其下发的层或下面的任何层。

可以将分层架构应用于四个视图中的任何一个，但流行的三层架构是应用与逻辑视图的风层架构。它将逻辑视图中的元素（类）组织到以下层：
- 表现层：包含实现用户界面或外包API的代码
- 业务逻辑层：包含业务逻辑的代码
- 数据持久化层：实现与数据库交互的逻辑的代码

分层架构缺点：
- 单个表现层：它无法展现应用程序可能不仅仅由单个系统调用、交互的事实
- 单一数据持久化层：它无法展现应用程序可能与多个数据库交互的事实
- 将业务逻辑层定义为依赖数据持久化层：理论上，这样的依赖会阻碍你在没有数据库的情况下测试业务逻辑（因为业务逻辑层依赖数据库）

#### 六边形架构风格

六边形架构风格选择以业务逻辑为中心的方式组织逻辑视图（4+1中的逻辑视图）。
应用程序具有一个或多个入站适配器，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。
同样，应用程序具有一个或多个出站适配器，而不是数据持久化层，这些出站适配器由业务逻辑调用，并调用外部应用程序。
此架构的关键优点是：业务逻辑不依赖适配器，适配器依赖业务逻辑，即业务逻辑稳定。

![screen_shot_1685533474244](https://github.com/lemonshen00/reading-record/assets/13763576/2959356a-b291-47ae-b8d3-198fda435e59)

关于六边形架构的举例说明：
业务逻辑具有一个或多个端口，端口定义一组操作，关于业务逻辑如何与外部交互。如在Java中，端口通常是Java接口。
有两种端口：入站和出站端口。入站端口是业务逻辑公开的API，外部应用程序可以调用它。入站端口的一个实例是服务接口，它定义服务的公共方法。
出站端口是业务逻辑调用外部系统的方式，出站端口的一个实例是存储库接口，它定义了数据访问操作的集合。

业务逻辑的周围是适配器，与端口一样，有两种适配器：入站和出站。入站适配器通过调用入站端口来处理来自外部世界的请求。
入站适配器的一个实例是Spring MVC Controller，它实现一组REST接口或一组Web页面。

出站适配器实现出站端口，并通过调用外部应用程序或服务 处理来自业务逻辑的请求。
出站适配器的一个实例，是实现访问数据库操作的DAO类。出站适配器也可以发布事件（即业务逻辑发布了一个事件）。

六边形架构风格的一个重要好处，是将业务逻辑与适配器中包含的表示层和数据访问层逻辑分离（即，数据访问层和表示层在适配器中），
业务逻辑不再依赖表示层或数据访问层，实现解耦。

在六边形架构中，可通过多个入站适配器调用业务逻辑，每个适配器实现特定的API或用户界面。业务逻辑还可以调用多个出站适配器，每个出站适配器调用不同的外部系统。
六边形架构是描述微服务架构中的，每个服务的架构的好方法。

### 2.1.3 微服务架构是一种架构风格

单体架构和微服务架构，都是一种架构风格。
> 模式：单体架构
将应用程序构建为单个可执行和可部署组件。

> 模式：微服务架构
将应用程序构建为松耦合、可独立部署的一组服务。

微服务强加的一个关键约束是**服务松耦合**，因此，服务之间的协作存在一定的限制。

#### 什么是服务
> 服务是一个单一的、可独立部署的软件组织，它实现了一些有用的功能。

图中的服务API，实际就是入站、出站适配器。

#### 共享类库的角色
应该努力使用共享库来实现不太可能改变的功能，例如用来实现币种转换等固定功能
可能改变的功能，应该作为服务来实现

#### 服务的大小并不重要
不要把关注点放在微服务的**微**字上，大小并不是一个重要的考虑因素。更好的目标是将服务定义为能够由小团队开发的服务，并且交付时间最短，与其他团队的协作最少。

> 如果你因为其他服务的变更而不断需要同步更新自己负责的服务，或者你所负责的服务正在出发其他服务的更新，表明没有实现松耦合。

## 2.2 为应用程序定义微服务架构
服务的分解有两种方式：一种源自业务架构学派的策略是定义与**业务能力**相对应的服务；
另一种策略是围绕**领域驱动设计的子域**来分解和设计服务。

服务的分解可能遇到几个障碍需要克服：
- 网络延迟
- 服务间的同步通信降低了可用性，需要使用自包含服务的概念处理
- 维护跨服务的数据一致性，需要使用Saga
- 上帝类，需要使用DDD消除上帝类

### 2.2.1 识别系统操作
需求（用户故事、用例）---->领域模型（用户故事中的 名词）----> 系统操作

用户下单，商户接单 ---->订单、餐馆、配送---->创建订单，接受订单

前置条件：当这个操作被调用时必须满足的条件

后置条件：当这个操作完成后，执行相关操作来完成和满足后置条件

### 2.2.2 根据业务能力进行服务拆分
业务能力是指能够为公司（或组织）产生价值的商业活动。例如，保险公司业务能力包括承保、理赔、账务和合规等。

> 模式：根据业务能力进行服务拆分

#### 业务能力定义了一个组织的工作
组织的业务能力通常是指这个组织的业务是做什么，它们通常是稳定的，与之相反，组织采用**何种方式**来实现他的业务能力，是随着时间不断变化的

![screen_shot_1685585459184](https://github.com/lemonshen00/reading-record/assets/13763576/7185851f-7e88-4acb-bc05-adb9c45986b3)

围绕业务能力划分微服务的一个关键好处是，因为业务能力是稳定的，所以最终的架构也将是稳定的。

架构的各个组件可能会随着业务的具体实现方式而变化，但是架构扔保持不变。

### 2.2.3 根据子域进行服务拆分
DDD为每一个子域定义单独的领域模型

领域模型就是一个领域内的知识，比如实体、值对象、聚合、聚合根、限界上下文等，

领域模型定义了当前领域的词汇表，DDD也成领域模型为**通用语言**

识别子域的方式：分析组织的业务能力（其实就是能干啥，提供了啥功能），产出的结果也与业务能力非常接近。

一个限界上下文对应**一个或一组**服务。

![screen_shot_1685587035885](https://github.com/lemonshen00/reading-record/assets/13763576/f6dabed2-3f0d-4461-8d66-31b6738fd518)

#### DDD与微服务架构是天生一对
- 限界上下文的概念，可以很好的跟微服务架构中的服务进行匹配
- 微服务架构的自治化团队负责服务开发的概念，也与DDD中每个领域模型都由一个独立团队负责开发的概念吻合
- 子域用于它自己的领域模型这个概念，为消除上帝类和优化服务提供了好办法

### 2.2.4 拆分的指导原则

面向对象的设计原则，可以用于指导微服务架构的设计工作。
- 第一个原则就是在定义类的职责是，应该遵循单一职责原则(Single Responsibility Principle，SRP)。
- 第二个原则是把类组成包是，应该遵循闭包原则(Common Closure Principle，CCP)。

#### SRP
类承担的职责越多，就越可能被修改，就越不稳定。每一个类只有一个职责，因此也只有一个理由对其修改，也就更加稳定。

我们在设计微服务架构时应该遵循SRP原则，设计小的、内聚的、仅仅含有单一职责的服务。这会大大提升它的稳定性。

例如，为客户获取餐食的每一个方面（订单获取、订单准备、送餐等）都由一个单一的服务承载。

#### CCP
> 在包中包含的所有类应该是对同类的变化的一个集合，也就是说，如果对包做出修改，需要调整的类应该都在这个包内。 ----Robert C. Martin

上述意味着，如果由于某些原因两个类的修改必须耦合先后发生，那么就应该把它们放在同一个包内。

这样做的目标是，当业务规则发生变化是，开发者只需要对一个交付包做出修改，而不是大规模的修改和重新编译整个应用。

采用闭包原则，极大地改善了应用程序的可维护性。


在微服务架构下采用CCP原则，这样我们就能把根据相同原因变化的服务放在一个组件内，这样可以控制服务的数量。

理想情况下，一个变更只会影响一个团队和服务。CCP是解决分布式单体这种可怕的反模式的法宝。


SRP和CCP是Bob制定的十一项原则中的两项，它们在开发微服务架构时特别有用。

其余的九个原则可能不适用于微服务，但适用于设计类和包时使用。

#### 总结
如下是将应用程序分解为服务的好方法

- 按业务能力拆分
- 按子域和限界上下文拆分
- SRP
- CCP


