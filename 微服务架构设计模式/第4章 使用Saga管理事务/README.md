## 4.1 微服务架构下的事务管理

跨服务的操作必须使用Saga（一种消息驱动的本地事务序列）来维护数据的一致性，而不是ACID事务。
Saga的挑战在于，只满足ACD（原子性、一致性、持久性），缺少传统ACID事务的隔离性。

### 4.1.1 微服务架构对分布式事务的需求
在单体应用中，只需要在函数名上加一个@Transational注解，就可以利用Spring框架提供的机制实现事务。
与之相反，微服务中需要实现跨多个微服务，访问多个数据库，在多个数据中实现一致性存在难度。

### 4.1.2 分布式事务的挑战
在多个服务、数据库和消息代理之间维持数据一致性的传统方式是采用分布式事务。
分布式事务的事实标准是XA，XA采用了`两阶段提交`来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。

想要使用分布式事务，则系统内的所有数据库、消息组件等都需要满足XA标准。但是很多NoSQL数据库（如MongoDB）不支持
XA标准的分布式事务。同样，一些消息代理如RabbiMQ和Kafka也不支持分布式事务。

分布式事务的另一个问题在于，它们本质上都是同步进程间通信，这会降低分布式系统的可用性。例如，为了让一个分布式事务完成
提交，所有参与事务的服务都必须可用。即分布式事务每增加一个事务参与方，都会进一步降低总体的可用性。

> 系统只能够在一致性、可用性和分区容错性三个属性中，同时保证两个 ----Eric Brewer

今天，架构师倾向于保证系统的可用性和分区容错性，放弃对数据强一致性的要求。

### 4.1.3 使用Saga模式维护数据一致性
Saga是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务带来的问题。
一个Saga表示需要更新多个服务中数据的一个系统操作。
Saga由一连串的本地事务组成，每一个本地事务负责更新它所在服务的私有数据库，这些操作依赖于ACID框架和函数库。

> 模式：Saga
> 
> 通过使用异步消息来协调一系列的本地事务，从而维护多个服务之间的数据一致性。

#### Saga使用补偿事务来回滚所做出的改变
传统ACID事务的一个重要特性是：可以轻松回滚事务，例如通过执行ROLLBACK语句，数据库可以撤销（回滚）目前为止所做的所有更改。

遗憾的是，Saga无法自动回滚，因为每个步骤都会将其更改提交到本地数据库。你必须编写所谓的*补偿事务*


![screen_shot_1686211072495](https://github.com/lemonshen00/reading-record/assets/13763576/cef8073c-f490-4363-b207-9ad488ed209a)


## 4.2 Saga的协调模式

有两种类型的Saga：
1. 协同式：把Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，它们通过交换事件的方式来进行沟通
2. 编排式：把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中。Saga编排器发出命令式消息给各个Saga参与方，指示这些参与方服务完成具体操作（本地事务）

### 4.2.1 协同式Saga
使用协同时，没有一个中央协调器会告诉Saga参与方该做什么，相反，Saga参与方订阅彼此的事件并做出相应的响应。

例如，如下流程：
1. Order Service创建一个处于APPROVAL_PENDING状态的Order并发布OrderCreated事件
2. Consumer Service消费OrderCreated事件，验证消费者是否可以下单，并发布ConsumerVerified事件
3. ......
4. 如果某个步骤失败，可以发布一个XXXFailed事件，由服务订阅并回滚

![screen_shot_1686214362382](https://github.com/lemonshen00/reading-record/assets/13763576/4ca70257-f6af-4b71-8f55-25a05511a635)

#### 使用协同式Saga时必须注意两点：
1. 确保Saga参与方将更新本地数据库和发布事件作为数据库事务的一部分，即数据库更新和事件发布必须是原子的。
2. 确保Saga参与方必须能够将接收到的每个事件映射到自己的数据上，即需要一个统一的ID。

#### 优点
- 简单：服务在创建、更新或删除业务对象时发布事件
- 松耦合：参与方订阅事件并且彼此之间不会因此产生耦合

#### 缺点
- 更难理解：与编排式不同，代码中没有一个单一地方定义了Saga，相反，协调式Saga的逻辑分布在每个服务的实现中。
- 服务之间的循环依赖关系：更容易存在环形依赖，被认为是一种不好的设计风格
- 紧耦合风险：每个Saga参与方都需要订阅所有影响它们的事件。例如，Accounting Service必须订阅所有可能导致消费者信用卡被扣款或退款的事件。因此，存在一种风险，即Accounting Service的内部代码需要与Order Service实现的订单生命周期代码保持同步更新。

我们通常使用编排式Saga来应对更加复杂的场景。

### 4.2.2 编排式Saga

开发人员定义一个编排器类，这个类的唯一职责就是告诉Saga的参与方应该做什么事情。
Saga编排器使用命令/异步响应方式与Saga的参与方服务通信。
为了完成Saga中的一个环节，编排器对某个参与方发出一个命令式消息，告诉这个参与方该做什么操作。
当参与方服务完成操作后，会给编排器发送一个答复消息，编排器处理这个消息，并决定Saga的下一步操作是什么。

![screen_shot_1686217145202](https://github.com/lemonshen00/reading-record/assets/13763576/e2ba647d-741a-4dff-bdfa-7cda9eb8898a)

注意：Saga编排器是Order Service的一部分，但他依然会向Order Service发消息，而不是直接更新本地的数据库。

#### 把Saga编排器视为一个状态机
状态机是建模Saga的一个好方法，*状态机*有一组状态和一组由事件触发的状态之间的转换组成。
每个转换都可以有一个动作，对于Saga来说动作就是对某个参与方的调用。
状态之间的转换由Saga参与方执行本地的事务完成触发。
当前状态和本地事务的*特定结果*决定了状态转换以及执行的动作。

![screen_shot_1686217490496](https://github.com/lemonshen00/reading-record/assets/13763576/a0fee52c-9eb0-41ab-afb5-23fa77d6c619)

注意：横线上的*发送*是给发送的点对点命令

#### 编排式Saga的好处
- 更简单的依赖关系：无循环依赖，因为只有编排器会调用参与方，参与方不会调用编排器。
- 较少的耦合：每个服务实现供编排器调用的API，因此它不需要指导Saga参与方发布的事件。
- 改善关注点隔离，简化业务逻辑：Saga的协调逻辑本地化在Saga编排器中，领域对象更简单，不需要它们参与的Saga

弊端：
- 编排器中存在过多的业务逻辑

除了最简单的情况，建议在架构中使用编排式Saga


## 4.3 解决隔离问题
ACID中的隔离属性（Isolation），可确保同时执行多个事务的结果，与顺序执行它们的结果相同。
数据库为每个ACID事务提供了具体对数据的独占访问权的错觉。
隔离使得编写并发执行的业务逻辑变得更加容易。

为什么Saga缺乏了隔离属性？
- 其他Saga可以在执行时更改该Saga所访问的数据
- 其他Saga可以在Saga完成更新之前读取数据，因此可能会暴露不一致的数据

因此Saga仅满足ACD三个属性：原子性、一致性、持久性

缺乏隔离性的问题：无法执行并发事务操作

### 4.3.1 缺乏隔离导致的问题
缺乏隔离导致三个问题：
- 丢失更新：一个Saga没有读取额更新，而是直接覆盖了另一个Saga所做的更改
- 脏读：一个事务或一个Saga读取了尚未完成的Saga所做的更新
- 不可重复读：一个Saga的两个不同步骤，读取同一个数据，但得到不同结果

#### 丢失更新
当一个Saga覆盖另一个Saga所做的更新时，就会发生丢失更新异常。例如：
1. Create Order Saga的第一步创建了Order
2. 当该Saga正在执行时，另一个Cancel Order Saga取消了这个Order
3. Create Order Saga的最后一步批注Order

此时，Create order Saga会忽略Cancel Order Saga所做的更新并覆盖它。

### 4.3.2 Saga模式下实现隔离的对策
有如下对策：
- 语义锁：应用程序级的锁
- 交换式更新：把更新操作设计成可以按任意顺序执行
- 悲观视图：重新排序Saga的步骤，以最大限度地降低业务风险
- 重读值：通过重写数据来防止脏写，以在覆盖数据之前验证它是否保持不变
- 版本文件：将更新记录下来，以便可以对它们重新排序
- 业务风险评级：使用每个请求的业务风险来动态选择并发机制

#### Saga的结构
一个Saga包含三种类型的事务：
- 可补偿性事务：即可以回滚的事务
- 关键性事务：Saga执行过程的关键点，如果关键性事务成功，则Saga将一直运行到完成
- 可重复性事务：在关键事务之后的事务，保证成功







#### 对策：语义锁
语义锁，例如可以通过Order.state字段，*_PENDING状态实现语义锁。
它们告诉试图访问Order对象的其他Saga，Order对象当前正处在一个Saga的处理过程中。

如果一个Saga已经被锁定，其他Saga访问时根据state状态，可以直接返回失败，或者阻塞等待，直到状态更新。

#### 对策：交换式更新
一个简单的对策是将更新操作设计为可交换的，如果可以按照任何顺序执行，则操作是可交换的。

#### 对策：悲观视图
重新排序Saga的步骤，以最大限度的降低由于脏读而导致的业务风险。

#### 对策：重读值
在更新之前重新读取记录，验证它是否未更改，然后更新记录。

#### 对策：版本文件
记录已经到达的操作，然后以正确的顺序执行操作

#### 对策：业务风险评级
一种基于业务风险选择并发机制的策略，低风险使用Saga；高风险使用分布式事务





