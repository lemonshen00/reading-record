## 4.1 微服务架构下的事务管理

跨服务的操作必须使用Saga（一种消息驱动的本地事务序列）来维护数据的一致性，而不是ACID事务。
Saga的挑战在于，只满足ACD（原子性、一致性、持久性），缺少传统ACID事务的隔离性。

### 4.1.1 微服务架构对分布式事务的需求
在单体应用中，只需要在函数名上加一个@Transational注解，就可以利用Spring框架提供的机制实现事务。
与之相反，微服务中需要实现跨多个微服务，访问多个数据库，在多个数据中实现一致性存在难度。

### 4.1.2 分布式事务的挑战
在多个服务、数据库和消息代理之间维持数据一致性的传统方式是采用分布式事务。
分布式事务的事实标准是XA，XA采用了`两阶段提交`来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。

想要使用分布式事务，则系统内的所有数据库、消息组件等都需要满足XA标准。但是很多NoSQL数据库（如MongoDB）不支持
XA标准的分布式事务。同样，一些消息代理如RabbiMQ和Kafka也不支持分布式事务。

分布式事务的另一个问题在于，它们本质上都是同步进程间通信，这会降低分布式系统的可用性。例如，为了让一个分布式事务完成
提交，所有参与事务的服务都必须可用。即分布式事务每增加一个事务参与方，都会进一步降低总体的可用性。

> 系统只能够在一致性、可用性和分区容错性三个属性中，同时保证两个 ----Eric Brewer

今天，架构师倾向于保证系统的可用性和分区容错性，放弃对数据强一致性的要求。

### 4.1.3 使用Saga模式维护数据一致性
Saga是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务带来的问题。
一个Saga表示需要更新多个服务中数据的一个系统操作。
Saga由一连串的本地事务组成，每一个本地事务负责更新它所在服务的私有数据库，这些操作依赖于ACID框架和函数库。

> 模式：Saga
> 
> 通过使用异步消息来协调一系列的本地事务，从而维护多个服务之间的数据一致性。

#### Saga使用补偿事务来回滚所做出的改变
传统ACID事务的一个重要特性是：可以轻松回滚事务，例如通过执行ROLLBACK语句，数据库可以撤销（回滚）目前为止所做的所有更改。

遗憾的是，Saga无法自动回滚，因为每个步骤都会将其更改提交到本地数据库。你必须编写所谓的*补偿事务*


![screen_shot_1686211072495](https://github.com/lemonshen00/reading-record/assets/13763576/cef8073c-f490-4363-b207-9ad488ed209a)


## 4.2 Saga的协调模式

有两种类型的Saga：
1. 协同式：把Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，它们通过交换事件的方式来进行沟通
2. 编排式：把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中。Saga编排器发出命令式消息给各个Saga参与方，指示这些参与方服务完成具体操作（本地事务）

### 4.2.1 协同式Saga
使用协同时，没有一个中央协调器会告诉Saga参与方该做什么，相反，Saga参与方订阅彼此的事件并做出相应的响应。

例如，如下流程：
1. Order Service创建一个处于APPROVAL_PENDING状态的Order并发布OrderCreated事件
2. Consumer Service消费OrderCreated事件，验证消费者是否可以下单，并发布ConsumerVerified事件
3. ......
4. 如果某个步骤失败，可以发布一个XXXFailed事件，由服务订阅并回滚

![screen_shot_1686214362382](https://github.com/lemonshen00/reading-record/assets/13763576/4ca70257-f6af-4b71-8f55-25a05511a635)

#### 使用协同式Saga时必须注意两点：
1. 确保Saga参与方将更新本地数据库和发布事件作为数据库事务的一部分，即数据库更新和事件发布必须是原子的。
2. 确保Saga参与方必须能够将接收到的每个事件映射到自己的数据上，即需要一个统一的ID。

#### 优点
- 简单：服务在创建、更新或删除业务对象时发布事件
- 松耦合：参与方订阅事件并且彼此之间不会因此产生耦合

#### 缺点
- 更难理解：与编排式不同，代码中没有一个单一地方定义了Saga，相反，协调式Saga的逻辑分布在每个服务的实现中。
- 服务之间的循环依赖关系：更容易存在环形依赖，被认为是一种不好的设计风格
- 紧耦合风险：每个Saga参与方都需要订阅所有影响它们的事件。例如，Accounting Service必须订阅所有可能导致消费者信用卡被扣款或退款的事件。因此，存在一种风险，即Accounting Service的内部代码需要与Order Service实现的订单生命周期代码保持同步更新。

我们通常使用编排式Saga来应对更加复杂的场景。

### 4.2.2 编排式Saga

开发人员定义一个编排器类，这个类的唯一职责就是告诉Saga的参与方应该做什么事情。
Saga编排器使用命令/异步响应方式与Saga的参与方服务通信。
为了完成Saga中的一个环节，编排器对某个参与方发出一个命令式消息，告诉这个参与方该做什么操作。
当参与方服务完成操作后，会给编排器发送一个答复消息，编排器处理这个消息，并决定Saga的下一步操作是什么。

![screen_shot_1686217145202](https://github.com/lemonshen00/reading-record/assets/13763576/e2ba647d-741a-4dff-bdfa-7cda9eb8898a)

注意：Saga编排器是Order Service的一部分，但他依然会向Order Service发消息，而不是直接更新本地的数据库。

#### 把Saga编排器视为一个状态机
状态机是建模Saga的一个好方法，*状态机*有一组状态和一组由事件触发的状态之间的转换组成。
每个转换都可以有一个动作，对于Saga来说动作就是对某个参与方的调用。
状态之间的转换由Saga参与方执行本地的事务完成触发。
当前状态和本地事务的*特定结果*决定了状态转换以及执行的动作。

![screen_shot_1686217490496](https://github.com/lemonshen00/reading-record/assets/13763576/a0fee52c-9eb0-41ab-afb5-23fa77d6c619)

注意：横线上的*发送*是给发送的点对点命令

#### 编排式Saga的好处
- 更简单的依赖关系：无循环依赖，因为只有编排器会调用参与方，参与方不会调用编排器。
- 较少的耦合：每个服务实现供编排器调用的API，因此它不需要指导Saga参与方发布的事件。
- 改善关注点隔离，简化业务逻辑：Saga的协调逻辑本地化在Saga编排器中，领域对象更简单，不需要它们参与的Saga

弊端：
- 编排器中存在过多的业务逻辑

除了最简单的情况，建议在架构中使用编排式Saga


## 4.3 解决隔离问题
